# Лабораторная работа №3. Эксперимент

- Копалина Майя Алексеевна P3232
- Вариант без усложнения: asm | risc | neum | hw | instr | struct | trap -> stream | mem | cstr | prob2 

### Описание варианта

```
- asm -- синтаксис ассемблера. Необходима поддержка label-ов.
- risc -- система команд должна быть упрощенной, в духе RISC архитектур:
    - стандартизированная длина команд;
    - операции над данными осуществляются только в рамках регистров;
    - доступ к памяти и ввод-вывод -- отдельные операции (с учётом специфики вашего варианта `mem/port`);
- neum -- фон Неймановская архитектура.
- hw (hardwired) -- ContolUnit реализуется как часть модели.
- instr -- процессор необходимо моделировать с точностью до каждой инструкции (наблюдается состояние после каждой инструкции).
- struct -- машинный код в виде высокоуровневой структуры данных. Считается, что одна инструкция укладывается в одно машинное слово.
- trap -- ввод-вывод осуществляется токенами через систему прерываний.
- mem -- memory-mapped (порты ввода-вывода отображаются в память и доступ к ним осуществляется штатными командами),
    - отображение портов ввода-вывода в память должно конфигурироваться (можно hardcode-ом).
- cstr -- Null-terminated (C string)
- prob2 -- Even Fibonacci numbers (сумма четных чисел Фибонначи, не превышающих 4 млн).
```

### Синтаксис
#### Форма Бэкуса-Наура
```
<программа> ::=
    "section .data" <перенос строки> {<данные> | <индекс>}
    "section .code" <перенос строки> {<инструкция> | <метка> | <индекс>}
    
<данные> ::= <метка переменной> ":" <переменная> [комментарий] <перенос строки>
<инструкция> ::= <адресная команда> <операнд> [комментарий] <перенос строки> | <безадресная команда> [комментарий] <перенос строки>
<метка> ::= <идентификатор> ":" [комментарий] <перенос строки>
<индекс> ::= "index" <число> [комментарий] <перенос строки>

<метка переменной> ::= <слово>
<переменная> ::= <число> | "'"<слово>"'"

<адресная команда> ::= "LD" | "ST" | "PUSH" | "POP" | "ADD" | "SUB" | "CMP" | "JMP" 
<безадресная команда> ::= "INC" | "DEC" | "HALT" | "IRET" | "NOP"
<операнд> ::= <число> | <метка переменной> | "$" <метка переменной>

<идентификатор> ::= "_"<слово>
<комментарий> ::= ";" {<слово> | <число>}

<перенос строки> ::= "\n"
<слово> ::= <буква> {<буква>}
<число> ::= ["-"]<цифра> {<цифра>}
<буква> ::= a | b | c | ... | z | A | B | C | ... | Z
<цифра> ::= 0 | 1 | 2 | .. | 8 | 9
```

#### Объяснение

Вся программа описывается в виде двух секций: `.data` и `.code`.
 - В секции `.data` описываются переменные, которые могут использоваться в секции `.code`.
 - В секции `.code` описываются инструкции, которые выполняются процессором.

В программе должна обязательно быть метка _start - входная точка

Каждая непустая строка программы это одно из нижеперечисленных:
 - Переменная: 
   - Может быть числом или строкой.
   - Строка заключается в одинарные кавычки.
   - Указывается значение посредством `:` после названия переменной.
 - Инструкция:
   - Команда может быть адресной или безадресной.
   - Состоит из команды и в случае адресной команды - операнда.
   - Операнд может быть числом, меткой переменной или меткой инструкции.
   - Команда должна быть записана в верхнем регистре.
 - Метка:
   - Используется для обозначения места в коде, к которому можно выполнить переход.
   - Метка должна начинаться с символа `_`.
 - Индекс:
   - Используется для обозначения ячейки памяти, в которую записываются последующие инструкции и данные.
   - Указывается ключевое слово `index` и число через пробел.
 - Адрес:
   - Указывается название переменной.
   - Если требуется ввод или вывод с устройства, то можно использовать параметры `IN`, `OUT`.
   - Может указываться название переменной с префиксом `$` для косвенной адресации.
   - Может указываться число как адрес.

### Организация памяти
- Память команд и данныx -- общая, в соответствии с моделью фон Неймана 
- Размер машинного слова -- `32` бит 
- Память содержит `2^11` ячеек
- Регистры:
   - Аккумулятор (ACC) -- хранит результаты вычислений.
   - Регистр адреса (AR) -- хранит адрес ячейки памяти.
   - Счетчик инструкций (IP) -- хранит адрес следующей инструкции.
   - Регистр данных (DR) -- хранит данные для передачи в память.
   - Указатель стека (SP) -- хранит адрес вершины стека.
   - Регистр команд (CR) -- хранит текущую инструкцию.
   - Регистр состояния (PS) -- хранит флаги состояния процессора в виде битов:
     - `N` - флаг отрицательности
     - `Z` - флаг нуля
     - Биты расположены в следующем порядке: `N`, `Z`
       
- program counter, data address - недоступны программисту и транслятору, внутренние регистры процессора

```text
            Registers
+------------------------------------+
| AC - аккумулятор                   |
+------------------------------------+
| IR - регистр инструкции            |
+------------------------------------+
| DR - регистр данных                |
+------------------------------------+
| PC - счётчик команд                |
+------------------------------------+
| SP - указатель стека               |
+------------------------------------+
| PS - состояние программы           |
+------------------------------------+

       Instruction memory
+------------------------------+
| 00  : jmp N                  |
|    ...                       |
| 10  : interruption vector 0  |
| 11  : interruption vector 1  |
|    ...                       |
| n   : program start          |
|    ...                       |
| i   : interruption handler 0 |
| i+1 : interruption handler 0 |
|    ...                       |
+------------------------------+

          Data memory
+------------------------------+
| 00  : constant 1             |
| 01  : constant 2             |
|    ...                       |
| l+0 : num literals           |
| l+1 : num literals           |
|    ...                       |
| c+0 : variable 1             |
|    ...                       |
+------------------------------+
```


### Система команд
  
- Таблица команд:

- Архитектура RISC(reg to reg). Количество аргументов от 0 до 3, аргументом может являться либо регистр, либо непосредственное значение

- Взаимодействие с памятью посредством инструкций `LD` и `ST`. Записать значение из памяти можно только в регистр. Загрузить в память можно только значение регистра.

- Взаимодействие с устройствами ввода/вывода - MMIO. Поэтому для того чтобы прочитать или записать символ достаточно воспользоваться инструкциями `LD` и `ST` с нужным адресом

- Счетчик команд указывает на исполняемую команду, он по умолчанию увеличивается на 1. Можно вмешаться при помощи инструкций безусловного(`JMP`) и условного(`JNZ`, `JG`) перехода. Можно прыгнуть либо на immediate value, либо на значение в регистре.

| Оператор | Арг1 | Арг2 | Арг3 | Влияние на NZ | Описание |
| -------- | ---- | ---- | ---- | ------------- | -------- |
| MOV      | REG  | REG/IMM | - | ? | АРГ1 <-- АРГ2, загружает в первый регистр значение второго аргумента |       
| LD       | REG  | REG/IMM | - | ? | Загружает в регистр значение в памяти по адресу равному второму аргументу  |       
| ST       | REG/IMM | REG | - | - | Загружает значение второго аргумента в ячейку памяти с адресом равным первому аргументу |
| ADD      | REG | REG | REG | + | АРГ1 <-- АРГ2 + АРГ3 |
| SUB      | REG | REG | REG | + | АРГ1 <-- АРГ2 - АРГ3 |
| DIV      | REG | REG | REG | + | АРГ1 <-- АРГ2 // АРГ3 |
| CMP      | REG | REG | - | + | Установить флаги как при операции АРГ1 - АРГ2 |
| JMP      | REG/IMM | - | - | - | Безусловный переход на инструкцию с номером АРГ1 |
| JZ      | REG/IMM | - | - | - | Переход на инструкцию с номером АРГ1, если установлен флаг Z |
| JNZ     | REG/IMM | - | - | - | Переход на инструкцию с номером АРГ1, если не установлен флаг Z |
| HALT     | - | - | - | - | Окончание симуляции |

Способ кодирования:
```
LD   REG  1          INT  268435456  
```
Сначала код инструкции, затем через пробельные символы аргументы. Аргумент описывается типом: REG или INT(immediate value). Одна инструкция - одна строка


### Транслятор

Интерфейс командной строки: translator.py <input_file> <target_file>

### Модель процессора

```
python csa_lab3/machine/main.py <FILE_WITH_COMMANDS> <FILE_WITH_INPUT>
```
#### Control Unit
Сигналы:
- `sel_next` - мультиплексор на вход в `Program Counter`, либо инкремент текущего значения, либо `control_unit_arg` (поддержка прыжка по значению регистра)
- `control_unit_arg` - получается из мультиплексора, который управляется `sel_arg`. Либо immediate value из инструкции, либо вывод alu_output из datapath
- `latch_pc` - сохранить значение на входе в `Program Counter`
#### Datapath
- `latch_data_addr` - сохранить значение на входе в `Data Address`
- `WR` - записать значение на входе в `data_memory` или в `output_device` в зависимости от `CS`
- `OE` - включит вывод значения из `data_memory` или `input_device` в зависимости от `CS`
- `sel_reg_input` - мультиплексор на входе в регистровый файл. Либо значение из памяти/устройства, либо `control_unit_arg` - может быть immediate value(а может быть значением другого регистра)
- `sel_lreg`, `sel_rreg`, `sel_ireg` - выбрать регистр (левый, правый или регистр, в который записывают)
- `latch_ireg` - сохранить значение на входе в регистровый файл, в выбранный регистр для записи
- `alu_signals` - выбор операции в ALU


### Тестирование

Раздел должен включать:

- Краткое описание разработанных тестов.
- Описание работы настроенного CI.
- Реализацию следующих алгоритмов (должны проверяться в рамках интеграционных тестов):

    1. `hello` -- напечатать hello world;

    1. `cat` -- печатать данные, поданные на вход симулятору через файл ввода (размер ввода потенциально бесконечен);

    1. `hello_user_name` -- запросить у пользователя его имя, считать его, вывести на экран приветствие (`<` -- ввод пользователя через файл ввода, `>` вывод симулятора):

        ```text
        > What is your name?
        < Alice
        > Hello, Alice!
        ```

    1. алгоритм согласно варианту;

    1. дополнительные алгоритмы, демонстрирующие особенности вашего варианта (синтаксис, работу специфических команд и т.п.).

- Необходимо показать работу разработанных алгоритмов.
    - Для одной из программ сделать подробное описание с комментариями в рамках отчёта, включая: использование разработанных программ, исходный код, машинный код, результат работы и журнал состояний модели процессора.
    - Для всех алгоритмов необходимо привести ссылки на их golden тесты. Они должны включать: алгоритм, машинный код и данные, ввод/вывод, журнал работы процессора.
    - Если размер журнала модели процессора слишком большой (сотни килобайт), его полное включение в golden test нецелесообразно. Необходимо адаптировать журнал под каждый алгоритм, добившись достаточной репрезентативности для проверки задания.
    - Все листинги исходного кода должны быть отформатированы.

Кроме того, в конце отчёта необходимо привести следующий текст для трёх реализованных алгоритмов (необходимо для сбора общей аналитики по проекту):

```text
| ФИО | <алг> | <LoC> | <code байт> | <code инстр.> | <инстр.> | <такт.> | <вариант> |
```

где:

- алг. -- название алгоритма (hello, cat, или как в варианте)
- прог. LoC -- кол-во строк кода в реализации алгоритма
- code байт -- кол-во байт в машинном коде (если бинарное представление)
- code инстр. -- кол-во инструкций в машинном коде
- инстр. -- кол-во инструкций, выполненных при работе алгоритма
- такт. -- кол-во тактов, которое заняла работа алгоритма

## Варианты

Вариант определяется:

- комбинацией особенностей языка программирования и архитектуры процессора;
- реализуемым алгоритмом;

| Особенность             |          |        |         |       |
|-------------------------|----------|--------|---------|-------|
| ЯП. Синтаксис           | alg      | lisp   | asm     | forth |
| Архитектура             | acc      | cisc   | risc    | stack |
| Организация памяти      | neum     | harv   |         |       |
| Control Unit            | hw       | mc     |         |       |
| Точность модели         | instr    | tick   |         |       |
| Представление маш. кода | struct   | binary |         |       |
| Ввод-вывод              | stream   | trap   |         |       |
| Ввод-вывод ISA          | mem      | port   |         |       |
| Тип строк               | cstr     | pstr   |         |       |
| Алгоритм                | prob1    | prob2  | prob5   |       |
| Усложнение              | pipeline | spi    | cache   |       |


### Архитектура

- `acc` -- система команд должна быть выстроена вокруг аккумулятора.
    - Инструкции -- изменяют значение, хранимое в аккумуляторе.
    - Ввод-вывод осуществляется через аккумулятор.
- `risc` -- система команд должна быть упрощенной, в духе RISC архитектур:
    - стандартизированная длина команд;
    - операции над данными осуществляются только в рамках регистров;
    - доступ к памяти и ввод-вывод -- отдельные операции (с учётом специфики вашего варианта `mem/port`);

### Архитектура организации памяти

Тип памяти -- однопортовая.

- `neum` -- фон Неймановская архитектура.
- `harv` -- Гарвардская архитектура:
    - в тестах необходимо привести/проверить как память команд, так и память данных.

### Control Unit

- `hw` -- hardwired. Реализуется как часть модели.

### Точность модели

- `instr` -- процессор необходимо моделировать с точностью до каждой инструкции (наблюдается состояние после каждой инструкции).

### Представление машинного кода

- `struct` -- в виде высокоуровневой структуры данных. Считается, что одна инструкция укладывается в одно машинное слово, за исключением CISC архитектур.

### Ввод-вывод

#### `stream`

Ввод-вывод осуществляется как поток токенов. Есть в примере. Логика работы:

- при старте модели у вас есть буфер, в котором представлены все данные ввода (`['h', 'e', 'l', 'l', 'o']`);
- при обращении к вводу (выполнение инструкции) модель процессора получает "токен" (символ) информации;
- если данные в буфере кончились -- останавливайте моделирование;
- вывод данных реализуется аналогично, по выполнении команд в буфер вывода добавляется ещё один символ;
- по окончании моделирования показать все выведенные данные;
- логика работы с буфером реализуется в рамках модели на Python.

#### `trap`

Ввод-вывод осуществляется токенами через систему прерываний. Логика работы:

- при старте модели у вас есть расписание ввода (`[(1, 'h'), (10, 'e'), (20, 'l'), (25, 'l'), (100, 'o')]`, где цифра -- момент поступления данных, символ -- токен);
- процессор имеет систему прерываний:
    - прерывания считаем внутренними;
    - обработка прерывания должна приводить к вызову реализованного пользователем программного кода;
    - обработчик прерывания реализуется программистом на вашем языке;
- в процессе моделирования идёт отсчёт времени в тактах, по наступлении события ввода -- происходит обработка прерывания;
- из журнала работы процессора должно быть ясно, работаете вы в прерывании или нет;
- вывод данных реализуется посимвольно, как в варианте `stream`, по выполнении команд в буфер вывода добавляется ещё один символ;
- по окончании моделирования показать все выведенные данные;
- ситуация наступления прерывания во время обработки прерывания должна быть проработана (способ -- на ваше усмотрение);
- логика работы с буферами реализуется в рамках модели на Python;
- не стоит путать "вызов прерывания" и "получение данных".

### Ввод-вывод ISA

Поддержка ввода-вывода с точки зрения системы команд.

- `mem` -- memory-mapped (порты ввода-вывода отображаются в память и доступ к ним осуществляется штатными командами),
    - отображение портов ввода-вывода в память должно конфигурироваться (можно hardcode-ом).
- `port` -- port-mapped (специальные инструкции для ввода-вывода)
    - адресация портов ввода-вывода должна присутствовать.

### Поддержка строк

Варианты:

- `cstr` -- Null-terminated (C string)
- `pstr` -- Length-prefixed (Pascal string)

Общие требования:

- Статические строки должны храниться в памяти данных.
- Один символ может храниться в одном машинном слове (несмотря на явную неэффективность).

### Алгоритм

- Входные данные должны подаваться через ввод.
- Результат должен быть подан на вывод.
- Формат ввода/вывода данных -- на ваше усмотрение.

#### prob2. Even Fibonacci numbers

[Project Euler. Problem 2](https://projecteuler.net/problem=2)

Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.


